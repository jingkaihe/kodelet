Execute TypeScript/JavaScript code with access to MCP tools.

This tool takes two parameters:
- code_path: Path to the TypeScript/JavaScript file to execute (relative to .kodelet/mcp/)
- description: optional brief description of what the code does

# Required workflow
1. Discover available servers in `.kodelet/mcp/servers/`.
2. Read generated files (`index.ts` + tool files) to get exact schemas.
3. Write/update scripts in `.kodelet/mcp/` using `file_write` / `file_edit` / `apply_patch`.
4. Execute using `code_path`.

# Key rules
- Never guess tool schemas; always read generated files first.
- Use ES module imports with `.js` extension (example: `./servers/lsp/index.js`).
- Use `console.log()` for output (return values are ignored).
- Prefer `file_edit` or `apply_patch` for small iterations to save tokens.
- Keep output focused: filter/summarize large datasets.
- Use try/catch for error handling.

# Generic outputs (`[key: string]: any`)
Sample structure first, then refine:
- Primitive: print type + value
- Array: print length + first item
- Object: print keys + value types

Example sampling pattern:
```typescript
const out = await someTool.someCall(params);
if (out == null) {
  console.log('null/undefined');
} else if (typeof out !== 'object') {
  console.log(`primitive (${typeof out}):`, out);
} else if (Array.isArray(out)) {
  console.log(`array length=${out.length}, first=`, out[0]);
} else {
  console.log('object keys:', Object.keys(out));
  for (const [k, v] of Object.entries(out)) {
    console.log(`${k}: ${Array.isArray(v) ? 'array' : typeof v}`);
  }
}
```

# Examples

<good-example>
# Discover and inspect schema first
file_read .kodelet/mcp/servers/lsp/index.ts
file_read .kodelet/mcp/servers/lsp/diagnostics.ts

# Create script
file_write .kodelet/mcp/check_diagnostics.ts
```typescript
import * as lsp from './servers/lsp/index.js';
const result = await lsp.diagnostics({ filePath: './main.go' });
console.log(Array.isArray(result) ? result.slice(0, 5) : result);
```

# Execute by path
code_execution { "code_path": "check_diagnostics.ts" }
</good-example>

<bad-example>
// Guessing schema without reading generated files
const result = await lsp.diagnostics('./main.go');
</bad-example>

<bad-example>
import * as lsp from './servers/lsp';
// Missing .js extension for ES modules
</bad-example>
