Execute TypeScript/JavaScript code with access to MCP tools.

# CRITICAL: Always Read Generated Files First

**DO NOT SPECULATE OR GUESS SCHEMAS - You MUST read the actual generated tool files before writing code.**

MCP tool files in `.kodelet/mcp/servers/` are auto-generated. Their schemas, parameters, and types vary.

## Mandatory Workflow

**Step 1: Discover available servers**
```bash
ls .kodelet/mcp/servers/
```

**Step 2: Read generated files to see exact schemas**

Use `file_read` to examine:
- Server's `index.ts` for exported functions
- Individual tool files for exact function signatures and parameters

```bash
file_read .kodelet/mcp/servers/lsp/index.ts
file_read .kodelet/mcp/servers/lsp/definition.ts
```

**Step 3: Write code using EXACT schema from files**

When reading tool files, look for:
- Function signatures (parameter names and types)
- Required vs optional parameters (`param` vs `param?`)
- JSDoc comments explaining parameters
- Return types (output schema)

**Pay Attention to Output Types**

Do not speculate the output schema. If the type is generic (`[key: string]: any`), sample it first:
- **Arrays**: Show length + first item (truncated to 500 chars)
- **Objects**: Show keys + value types + sizes in bytes

## Workspace Structure

```
.kodelet/mcp/                   # Workspace root
├── package.json                # ES module configuration
├── client.ts                   # MCP RPC client (auto-generated)
├── servers/                    # MCP tool wrappers by server
│   ├── lsp/                    # Example: Language Server tools
│   │   ├── index.ts           # Exported functions
│   │   ├── definition.ts      # Find symbol definitions
│   │   └── diagnostics.ts     # Get file diagnostics
│   └── [other-servers]/       # Other MCP servers
└── .kodelet/mcp.sock          # Unix socket for RPC
```

## Import Conventions

Always use relative ES module imports with `.js` extension:

```typescript
// CORRECT
import * as lsp from './servers/lsp/index.js';

// INCORRECT - missing .js or absolute path
import * as lsp from './servers/lsp/index';
import * as lsp from './.kodelet/mcp/servers/lsp/index.js';
```

**Why**: Workspace uses ES modules (`"type": "module"`) requiring explicit file extensions.

# Important Rules

* Always read generated tool files before writing code - no speculation
* Use `file_read` to examine tool schemas and function signatures
* Use relative imports with `.js` extension for ES modules
* Use `console.log()` for output - return statements are ignored
* Always filter and limit output - avoid logging arrays >100 items
* Log summaries and counts instead of raw data
* Use try/catch for error handling
* Keep each execution focused on one specific task
* Break complex workflows into multiple executions

# Examples

<good-example>
# Step 1: Discover servers
ls .kodelet/mcp/servers/
# Output: lsp/  grafana/

# Step 2: Read exact schema
file_read .kodelet/mcp/servers/lsp/diagnostics.ts
# See: function diagnostics(args: { filePath: string; contextLines?: boolean })

# Step 3: Write code with exact schema
import * as lsp from './servers/lsp/index.js';
const result = await lsp.diagnostics({ filePath: './main.go' });
console.log(`Found ${result.errors?.length || 0} errors`);
<reasoning>
Read generated files first to discover exact schema, then use it.
</reasoning>
</good-example>

<bad-example>
import * as lsp from './servers/lsp/index.js';
// Guess the schema without reading files
const result = await lsp.diagnostics('./main.go');
<reasoning>
Never guess schemas. Always read generated files first to see exact function signatures.
</reasoning>
</bad-example>

<bad-example>
# After reading file: export interface myToolResponse { [key: string]: any; }
const result = await tool.myTool({ param: "value" });
// Directly access fields without sampling structure first
console.log(result.field1, result.field2);
<reasoning>
Generic output types require sampling first to discover actual fields.
</reasoning>
</bad-example>

<good-example>
# After reading file: export interface myToolResponse { [key: string]: any; }
# Sample tactically to discover structure
const sample = await tool.myTool({ param: "value" });

if (Array.isArray(sample)) {
  console.log(`Array[${sample.length}], first item (500 chars):`,
    JSON.stringify(sample[0], null, 2).substring(0, 500));
} else {
  Object.keys(sample).forEach(k => {
    const size = JSON.stringify(sample[k]).length;
    const type = Array.isArray(sample[k]) ? 'array' : typeof sample[k];
    console.log(`${k}: ${type} (${size} bytes)`);
  });
}

# Now use discovered fields
const result = await tool.myTool({ param: "production" });
console.log(`Status: ${result.status}, Count: ${result.count}`);
<reasoning>
Sample generic types tactically first, then use discovered fields.
</reasoning>
</good-example>

<good-example>
import * as lsp from './servers/lsp/index.js';

try {
  const def = await lsp.definition({ symbolName: 'processData' });
  const diags = await lsp.diagnostics({ filePath: def.filePath });
  
  // Filter output - log summaries only
  console.log(`Found at: ${def.filePath}`);
  console.log(`${diags.errors?.length || 0} errors, ${diags.warnings?.length || 0} warnings`);
  
  if (diags.errors?.length > 0) {
    diags.errors.slice(0, 5).forEach(err => 
      console.log(`  Line ${err.line}: ${err.message}`)
    );
  }
} catch (error) {
  console.error('Failed:', error.message);
}
<reasoning>
Chains tools, filters output to show summaries, uses try/catch, limits array output.
</reasoning>
</good-example>

<bad-example>
const files = await filesystem.listFiles({ path: '/' });
console.log(files);
<reasoning>
May return thousands of files. Always filter and summarize before logging.
</reasoning>
</bad-example>

<good-example>
const files = await filesystem.listFiles({ path: '/' });
console.log(`Found ${files.length} files total`);
console.log(`Go files: ${files.filter(f => f.endsWith('.go')).length}`);
console.log('Sample:', files.slice(0, 5));
<reasoning>
Filters and summarizes data before logging to avoid massive output.
</reasoning>
</good-example>

<bad-example>
import * as lsp from './servers/lsp';
<reasoning>
Missing .js extension. ES modules require explicit file extensions.
</reasoning>
</bad-example>

<good-example>
import { readdirSync } from 'fs';
const servers = readdirSync('./servers');
console.log('Available servers:', servers);
<reasoning>
Dynamic discovery of available MCP servers within TypeScript code.
</reasoning>
</good-example>

# Workspace Conventions

* **Working directory**: Code executes in `.kodelet/mcp/`
* **Module system**: ES modules only (no CommonJS)
* **Runtime**: Node.js with tsx (TypeScript execution)
* **Network**: Available for MCP RPC via Unix socket
* **File system**: Full access to workspace directory
