// client.ts - MCP client wrapper for code execution environment
// This file is automatically generated - do not edit

const MCP_RPC_ENDPOINT = process.env.MCP_RPC_ENDPOINT || "./.kodelet/mcp.sock";

interface MCPRequest {
  tool: string;
  arguments: Record<string, any>;
}

interface MCPResponse {
  content: Array<{ type: string; text?: string }>;
  structuredContent?: any;  // MCP 2025-06-18: structured output
  isError?: boolean;
}

export async function callMCPTool<T>(toolName: string, args: Record<string, any>): Promise<T> {
  const request: MCPRequest = {
    tool: toolName,
    arguments: args,
  };
  
  // Call MCP tool via RPC mechanism (Unix socket)
  const response = await fetch(MCP_RPC_ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(request),
  });
  
  if (!response.ok) {
    throw new Error(`MCP tool ${toolName} failed: ${response.statusText}`);
  }
  
  const result: MCPResponse = await response.json();
  
  if (result.isError) {
    throw new Error(`MCP tool ${toolName} error: ${JSON.stringify(result.content)}`);
  }
  
  // Prefer structured content if available (MCP 2025-06-18)
  if (result.structuredContent !== undefined) {
    return result.structuredContent as T;
  }
  
  // Fallback: extract text content and parse as JSON
  const textContent = result.content
    .filter(c => c.type === "text")
    .map(c => c.text)
    .join("");
  
  try {
    return JSON.parse(textContent) as T;
  } catch {
    // If not JSON, return as-is
    return textContent as unknown as T;
  }
}
